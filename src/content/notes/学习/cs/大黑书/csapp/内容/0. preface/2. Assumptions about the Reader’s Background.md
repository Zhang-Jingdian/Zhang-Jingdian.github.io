This book focuses on systems that execute x86-64 machine code. x86-64 is the latest in an evolutionary path followed by Intel and its competitors that started with the 8086 microprocessor in 1978.

Due to the naming conventions used by Intel for its microprocessor line, this class of microprocessors is referred to colloquially as “x86.”

As semiconductor technology has evolved to allow more transistors to be integrated onto a single chip, these processors have progressed greatly in their computing power and their memory capacity.

As part of this progression, they have gone from operating on 16-bit words, to 32-bit words with the introduction of IA32 processors, and most recently to 64-bit words with x86-64.

---

We consider how these machines execute C programs on Linux.

Linux is one of a number of operating systems having their heritage in the Unix operating system developed originally by Bell Laboratories. Other members of this class of operating systems include Solaris, FreeBSD, and MacOS X.

In recent years, these operating systems have maintained a high level of compatibility through the efforts of the Posix and Standard Unix Specification standardization efforts. Thus, the material in this book applies almost directly to these “Unix-like” operating systems.

---

The text contains numerous programming examples that have been compiled and run on Linux systems. 

We assume that you have access to such a machine, and are able to log in and do simple things such as listing files and changing directories. 

If your computer runs Microsoft Windows, we recommend that you install one of the many different virtual machine environments (such as VirtualBox or VMWare) that allow programs written for one operating system (the guest OS) to run under another (the host OS).

---

We also assume that you have some familiarity with C or C++. 

If your only prior experience is with Java, the transition will require more effort on your part, but we will help you. 

Java and C share similar syntax and control statements.

However, there are aspects of C (particularly pointers, explicit dynamic memory allocation, and formatted I/O) that do not exist in Java. 

Fortunately, C is a small language, and it is clearly and beautifully described in the classic “K&R” text by Brian Kernighan and Dennis Ritchie. 

Regardless of your programming background, consider K&R an essential part of your personal systems library.

If your prior experience is with an interpreted language, such as Python, Ruby, or Perl, you will definitely want to devote some time to learning C before you attempt to use this book.

---

Several of the early chapters in the book explore the interactions between C programs and their machine-language counterparts.

The machine-language examples were all generated by the GNU gcc compiler running on x86-64 processors. We do not assume any prior experience with hardware, machine language, or assembly-language programming

---

1. Linux
2. C