### **Vue.js 相关**

#### **1. Vue2 和 Vue3 的区别**

这是必考题。你可以从核心原理、API、生态和性能几个方面来回答：

- **响应式原理**: **Vue2** 使用 `Object.defineProperty()` 来劫持数据，但它有缺陷，比如无法直接监听到对象属性的新增/删除和数组基于索引的修改。**Vue3** 使用 `Proxy` 对象重写了响应式系统，它能原生劫持整个对象，解决了 Vue2 的所有缺陷，并且性能更好。
    
- **API 设计**: **Vue2** 主要使用**选项式 API (Options API)**，代码逻辑分散在 `data`, `methods`, `computed` 等选项中，当组件变大时，相关逻辑会被拆分，难以维护。**Vue3** 主推**组合式 API (Composition API)**，可以让你根据逻辑功能来组织代码，代码更内聚、更易复用和维护。你在“品优生活”项目中就实践了这一点，可以作为很好的例子。
    
- **性能提升**: Vue3 在编译、更新、内存占用等方面都做了优化。例如，它引入了**静态提升 (Static Hoisting)** 和**补丁标记 (Patch Flags)**，在编译时分析模板，对静态内容和动态内容进行标记，从而在更新时跳过静态部分，只更新动态部分，大大提升了渲染性能。
    
- **新特性**: Vue3 引入了许多新功能，如 **Teleport** (传送门)、**Suspense** (异步组件加载)、**Fragments** (支持多个根节点)等，并提供了更好的 **TypeScript** 支持。
    
- **生态工具**: **Vite** 成为了 Vue3 默认的构建工具，提供了极速的开发服务器启动和热更新体验，比 Webpack 快得多。
    

---

#### **2. 响应式原理**

这个问题是上一个问题的深入。

- **Vue2**: 核心是 `Object.defineProperty()`。它会遍历一个对象的所有属性，并把它们转换为 `getter/setter`。当读取属性时，会触发 `getter` 进行**依赖收集**（记录下谁依赖了这个数据）；当修改属性时，会触发 `setter` 来**通知更新**（通知所有依赖该数据的观察者去更新视图）。
    
- **Vue3**: 核心是 `Proxy` 和 `Reflect`。`Proxy` 像是在目标对象上加了一层“代理”，任何对该对象的操作（如读取、设置、删除属性等13种操作）都会被这个代理拦截，从而实现依赖收集和派发更新。`Proxy` 的性能优势在于它不需要在初始化时就遍历所有属性，而是惰性地在访问属性时才进行处理。
    

---

#### **3. 集成手势动画和效果**

结合你的“图享壁纸”项目来回答。

“在‘图享壁纸’项目中，为了提升用户体验，我主要通过两种方式集成了手势和动画：

1. **手势操作**: 我利用了 uni-app 提供的原生触摸事件 (`@touchstart`, `@touchmove`, `@touchend`) 来实现自定义手势。例如，在高清预览界面，我监听了双指的距离变化，通过计算实现了图片的**双指缩放**功能；同时监听了用户的长按事件，实现了**长按保存**壁纸的功能。
    
2. **动画效果**: 主要使用 **CSS3 的 `transition` 和 `animation`**。比如，页面切换时使用了淡入淡出的过渡效果，图片加载时有一个渐显的效果，这些都让交互变得更加自然、不生硬。对于更复杂的动画，也可以考虑引入像 `GSAP` 这样的专业动画库。”
    

---

#### **4. 组合式 API 和选项式 API 的最大区别**

- **核心区别在于代码组织方式**。
    
- **选项式 API (Options API)** 是“**按选项组织**”。一个功能的逻辑，比如获取用户数据，它的 `data`、`methods`、`computed`、`watch` 可能会散落在代码的不同位置。
    
- **组合式 API (Composition API)** 是“**按逻辑功能组织**”。你可以把同一个功能（如获取用户数据）的所有相关代码（包括状态、方法、计算属性等）都放在同一个 `setup` 函数内，或者抽离成一个独立的 `use` 函数（即 Composable）。
    
- **优势**: 组合式 API 使得**逻辑复用**变得非常简单和优雅，也让大型复杂组件的代码**可读性和可维护性**大大提高。你可以强调在“品优生活”项目中，使用 Composition API 让代码复用率提升了50%。
    

---

#### **5. Pinia 和 Vuex 有什么区别**

“Pinia 是 Vue 官方推荐的新一代状态管理库，可以看作是 Vuex 5。我在‘品优生活’项目中就使用了 Pinia，相比 Vuex，它有几个显著的优势：

- **更简洁的 API**: Pinia 没有 `mutations`，可以直接在 `actions` 中修改 `state`，无论是同步还是异步操作都统一在 `actions` 中处理，心智负担更小。
    
- **更好的 TypeScript 支持**: Pinia 的 API 设计对类型推导非常友好，你几乎不需要添加额外的类型定义就能获得完整的类型提示。
    
- **模块化设计**: 每个 store 都是一个独立的模块，你只需要在使用它的组件中导入即可，不像 Vuex 那样需要在一个地方注册所有模块。
    
- **更小的体积**: Pinia 的体积非常小，对项目打包更有优势。”
    

---

### **前端工程化与适配**

#### **6. 响应式设计是怎么实现的**

“响应式设计的核心是**让一套代码能够在不同尺寸的设备上都有良好的显示效果**。主要通过以下技术实现：

1. **媒体查询 (Media Queries)**: 这是响应式设计的基石。通过 `@media` 规则，我们可以为不同范围的屏幕宽度设置不同的 CSS 样式。
    
2. **弹性布局 (Flexible Layouts)**: 使用 **Flexbox** 或 **Grid** 来创建布局，它们能让元素根据可用空间自动调整大小和位置。
    
3. **相对单位 (Relative Units)**: 尽量使用相对单位如 `rem`, `vw`, `%`，而不是固定单位 `px`，这样元素尺寸可以随屏幕大小等比例缩放。”
    

---

#### **7. 界面要怎么做适配**

这是上一个问题的具体实现。你可以提到你简历中写的 `postcss-px-to-viewport`。

“在移动端项目（比如‘图享壁纸’）中，为了实现精准的UI适配，我主要采用了 `vw` 方案，并结合 `postcss-px-to-viewport` 这个 PostCSS 插件。它的工作原理是在编译时，自动将我们写的 `px` 单位转换成 `vw` 单位。这样，我们只需要按照设计稿的 `px` 值进行开发，插件会帮我们完成适配工作，保证在不同尺寸的手机屏幕上，UI都能等比例缩放，最大程度地还原设计稿。”

---

#### **8. 怎么确定大屏、小屏来响应适配**

“我们通过设置**断点 (Breakpoints)** 来区分不同尺寸的屏幕。断点就是一个个屏幕宽度的临界值。比如，我们可以定义：

- 小于 768px 是手机（小屏）
    
- 768px 到 992px 是平板（中屏）
    
- 大于 992px 是桌面电脑（大屏）
    

然后在 CSS 的媒体查询中，我们就可以根据这些断点来写不同的样式，从而实现响应式布局。”

---

#### **9. 怎么实现横竖屏切换**

“横竖屏切换的适配主要通过 CSS 的**媒体查询**和 `orientation` 特性来实现。

- `@media (orientation: portrait)`: 针对竖屏状态下的样式。
    
- `@media (orientation: landscape)`: 针对横屏状态下的样式。
    

在这些媒体查询块中，我们可以为布局、字体大小等编写不同的样式，来应对横竖屏切换时的界面变化。”

---

#### **10. 组件化开发架构是怎么实现的**

“组件化开发的核心思想是**分而治之**，将一个复杂的 UI 拆分成一个个独立的、可复用的**组件 (Component)**。

在我的项目中，我遵循以下原则来构建组件化架构：

1. **识别可复用部分**: 在项目初期，我会和设计师一起分析设计稿，识别出可以复用的 UI 元素，比如按钮、弹窗、列表项等，将它们设计成**基础组件**。
    
2. **封装业务逻辑**: 对于一些包含特定业务逻辑的模块，比如‘品优生活’项目中的 **SKU 选择器**、**购物车**，我会将它们封装成**业务组件**。
    
3. **明确组件职责**: 每个组件都应该有单一的职责，做好自己的事。
    
4. **数据流清晰**: 遵循**单向数据流**原则，数据通过 **Props** 从父组件传递到子组件，子组件通过**事件 ($emit)** 将消息传递给父组件。对于复杂的跨组件通信，则使用 **Pinia** 进行统一的状态管理。”
    

---

#### **11. 兄弟组件要怎么传数据**

1. **通过父组件中转 (Lifting State Up)**: 这是最常见的方式。一个兄弟组件通过 `$emit` 将数据传给父组件，父组件再通过 `props` 将数据传给另一个兄弟组件。
    
2. **事件总线 (Event Bus)**: 可以创建一个全局的 Vue 实例作为事件总线，一个组件通过它触发事件，另一个组件监听该事件。但在 Vue3 中，这种方式因为可能导致数据流混乱，已经不被推荐。
    
3. **状态管理库 (Pinia/Vuex)**: 这是处理复杂数据共享的最佳实践。将共享的状态存储在 Pinia store 中，任何组件都可以读取和修改这份数据，并且变化是响应式的。
    

---

### **性能优化与项目实践**

#### **12. 无限加载流畅体验是怎么实现的**

“在‘图享壁纸’项目中，我使用了 **Intersection Observer API (交叉观察器)** 来实现无限加载。

具体步骤是：

1. 在列表的底部放置一个“哨兵”元素。
    
2. 创建一个 Intersection Observer 来观察这个“哨兵”元素。
    
3. 当用户向下滚动，“哨兵”元素进入视口时，Observer 的回调函数就会被触发。
    
4. 在回调函数中，我向后端请求下一页的数据，并将返回的数据追加到现有列表的末尾。
    

相比于监听 `scroll` 事件，使用 Intersection Observer 的性能开销要小得多，因为它不会在滚动过程中被频繁触发，从而保证了流畅的体验。”

---

#### **13. 如果数据很多的时候怎么办**

“当一次性需要展示的数据量非常大时（比如成千上万条），直接全部渲染到 DOM 中会导致页面卡顿甚至崩溃。这时就需要采用**虚拟滚动 (Virtual Scrolling)** 技术。”

---

#### **14. 怎么实现虚拟滚动**

“虚拟滚动的核心思想是**只渲染视口内可见的区域**。

我的实现思路是：

1. 计算出所有列表项的总高度，并将其设置给一个容器元素，这样可以撑开滚动条，让滚动条看起来是正常的。
    
2. 监听容器的滚动事件，根据当前的滚动位置 (`scrollTop`)，计算出当前视口内应该显示哪些数据项。
    
3. 只将计算出的这部分数据项渲染成 DOM 元素，并使用 CSS 的 `transform: translateY()` 属性将它们定位到正确的位置。
    
4. 当用户滚动时，不断更新渲染的 DOM 元素和它们的 `translateY` 值。”
    

---

#### **15. 虚拟滚动原理**

（这个问题和上一个很像，你可以把回答合并或说得更原理化一些）

“虚拟滚动的原理，本质上就是用一个‘**可见区域的窗口**’在‘**全部数据的长列表**’上移动。我们只创建和渲染这个‘窗口’内的 DOM 元素，而不是全部。通过计算滚动偏移量，来动态更新‘窗口’内应该展示哪些数据，以及它们在容器内的精确位置，从而用有限的 DOM 元素模拟出无限列表的滚动效果。”

---

#### **16. 说一下路由守卫**

“路由守卫是 `vue-router` 提供的一种导航拦截机制。它允许我们在路由发生变化前、后或期间执行一些逻辑，最常见的应用场景就是**权限控制**和**数据预取**。”

---

#### **17. 有哪些路由守卫**

“`vue-router` 提供了三类路由守卫：

1. **全局守卫**:
    
    - `router.beforeEach`: 全局前置守卫，在任何路由跳转之前都会被调用。最常用于检查用户登录状态。
        
    - `router.afterEach`: 全局后置守卫，在路由跳转之后被调用，不接受 `next` 函数，不会改变导航本身。
        
2. **路由独享守卫**:
    
    - `beforeEnter`: 直接在路由配置上定义，只在进入这个路由时触发。
        
3. **组件内守卫**:
    
    - `beforeRouteEnter`: 在渲染该组件的对应路由被确认前调用，此时还**无法访问组件实例 `this`**。
        
    - `beforeRouteUpdate`: 在当前路由改变，但该组件被复用时调用（例如 `/user/1` -> `/user/2`）。
        
    - `beforeRouteLeave`: 在导航离开该组件的对应路由时调用。
        

在‘智慧餐饮管理系统’中，我主要使用了全局前置守卫 `beforeEach`，在里面判断用户是否持有有效的 Token，如果没有就重定向到登录页，从而实现了系统的权限控制。”

---

#### **18. 高清预览怎么实现**

“在‘图享壁纸’项目中，为了优化加载速度和流量消耗，我实现了高清预览功能：

1. **列表页加载缩略图**: 在壁纸列表页，我只展示经过压缩的、文件体积较小的缩略图。
    
2. **点击时加载原图**: 当用户点击某张壁纸时，会弹出一个模态框（Modal/Overlay）。在这个时候，我才开始加载并显示对应的高清原图。
    
3. **加载状态**: 在高清原图加载完成前，可以显示一个 loading 动画或者继续显示缩略图，以提升用户体验。”
    

---

#### **19. 统一封装网络请求是怎么实现的**

“在项目中，为了方便管理和复用，我会对网络请求进行统一封装，主要是基于 `axios`：

1. **创建 Axios 实例**: 使用 `axios.create()` 创建一个实例，并配置基础信息，如 `baseURL`（API 的基础路径）和 `timeout`（请求超时时间）。
    
2. **封装请求拦截器 (Request Interceptor)**: 在请求被发送出去之前进行拦截。我通常在这里统一添加请求头，比如 `Content-Type`，以及从 Pinia 或本地存储中读取 Token 并附加到 `Authorization` 头上。
    
3. **封装响应拦截器 (Response Interceptor)**: 在收到响应后进行拦截。我在这里对数据进行预处理，比如直接返回 `response.data`，省去在每个请求中都写 `.data`。同时，也在这里进行统一的**错误处理**。”
    

---

#### **20. 网络请求怎么做错误处理**

“在刚才提到的 `axios` 响应拦截器中，我会对错误进行统一处理：

1. **判断响应状态码**: 通过 `error.response.status` 来判断错误类型。
    
    - **401 (Unauthorized)**: 通常表示 Token 失效或未认证。我会清除本地的用户信息和 Token，并重定向到登录页。
        
    - **403 (Forbidden)**: 表示用户无权访问该资源，可以提示用户“权限不足”。
        
    - **404 (Not Found)**: 请求的资源不存在。
        
    - **5xx (Server Error)**: 服务器端错误，可以统一提示“服务器开小差了，请稍后再试”。
        
2. **处理网络错误**: 如果 `error.response` 不存在，说明是网络本身的问题（比如断网），可以提示“网络连接失败”。
    
3. **用户反馈**: 对于捕获到的错误，我会使用 Element Plus 或 Vant 的消息提示组件（如 Message 或 Toast）给用户一个清晰的反馈。
    
4. **Promise Reject**: 最后，`return Promise.reject(error)`，这样具体的业务代码里如果需要，还可以用 `.catch` 进行特定的错误处理。”
    

---

### **JavaScript 基础**

(这部分是考察你的 JS 功底，非常重要)

#### **21. ES6 和 ES5 有什么不一样**

“ES6 (ES2015) 是 JavaScript 的一个重大版本更新，带来了许多提升开发效率和代码可读性的新特性，主要包括：

- **新的变量声明**: `let` 和 `const`，提供了块级作用域。
    
- **箭头函数**: 更简洁的函数语法，并且不绑定自己的 `this`。
    
- **Promise**: 解决了回调地狱问题，是现代异步编程的基础。
    
- **类 (Class)**: 提供了更接近传统面向对象语言的语法糖来创建构造函数。
    
- **模块化**: `import` 和 `export`，使得 JS 可以进行模块化开发。
    
- **其他语法糖**: 模板字符串、解构赋值、展开/剩余运算符等。”
    

---

#### **22. const，var，let 的区别**

|特性|`var`|`let`|`const`|
|---|---|---|---|
|**作用域**|函数作用域|块级作用域|块级作用域|
|**变量提升**|**会**|不会 (存在暂时性死区)|不会 (存在暂时性死区)|
|**重复声明**|**可以**|不可以|不可以|
|**修改值**|**可以**|**可以**|**不可以** (基本类型)|

**补充**: `const` 声明的如果是对象或数组，其内部的属性或元素是可以修改的，只是不能重新给这个变量赋值。

---

#### **23. 说一下变量提升和函数提升**

- **变量提升 (Variable Hoisting)**: 使用 `var` 声明的变量，其**声明**部分会被提升到其所在作用域的顶部，但**赋值**部分不会。这意味着在声明之前访问该变量，其值为 `undefined`。
    
- **函数提升 (Function Hoisting)**: 使用 `function` 关键字声明的函数，其**整个函数体**都会被提升到作用域顶部。这意味着可以在函数声明之前调用它。
    
- **注意**: 函数表达式（如 `var foo = function() {}`）遵循的是变量提升的规则，只有变量名 `foo` 被提升了，赋值的函数体没有。
    

---

#### **24. const，let，var 哪个可以变量提升**
`var` 会变量提升。`let` 和 `const` 不会（或者更准确地说，它们存在暂时性死区，导致在声明前无法访问，实际效果上阻止了变量提升带来的问题）。

“`let` 和 `const` 理论上也会被提升，但它们存在一个**暂时性死区 (Temporal Dead Zone, TDZ)**。这意味着从块级作用域的顶部到该变量声明语句之间，访问该变量会抛出 `ReferenceError`。所以从实际效果来看，我们可以认为它们是**不会被提升**的。”

---

#### **25. 场景：一个按钮，点一次发送一次信息，如果我连续点很多次，这种情况要怎么处理**

“这是一个非常经典的防止用户重复提交的场景，可以有几种处理方式：

1. **加锁机制**: 在第一次点击后，立即禁用按钮（比如设置 `disabled` 属性），或者显示一个 loading 状态。在网络请求完成后，再恢复按钮的可用状态。这是最简单直接的方法。
    
2. **函数防抖 (Debounce)**: 如果场景是希望用户停止点击一段时间后再执行操作（比如搜索框），可以使用防抖。
    
3. **函数节流 (Throttle)**: 如果场景是希望在一定时间内最多只执行一次操作，可以使用节流。对于“发送信息”这个场景，节流比防抖更合适，因为它能保证在用户连续点击时，信息能以一个固定的频率（比如每2秒一次）被发送出去，而不是完全不发送。
    

综合来看，对于这个场景，**加锁机制**是最常用和最有效的。”

---

#### **26. 你能说说防抖和节流吗**

- **防抖 (Debounce)**: 想象一下电梯关门。只要有人进来，电梯就会重置关门倒计时。防抖就是，在事件被触发后，等待一个固定的时间，如果在这段时间内没有再次触发该事件，则执行函数；如果再次触发，则重新计时。**核心是：只在最后一次触发后执行**。
    
    - **应用场景**: 输入框搜索联想、窗口大小调整 (`resize`)。
        
- **节流 (Throttle)**: 想象一下技能冷却。你放了一个技能后，必须等冷却时间结束才能再次释放。节流就是，在规定时间内，函数最多只能执行一次，无论这期间事件被触发了多少次。**核心是：固定频率执行**。
    
    - **应用场景**: 页面滚动监听 (`scroll`)、拖拽、高频次的按钮点击。
        

---

#### **27. 说一下闭包**

“闭包是指**一个函数能够访问其词法作用域（定义时的作用域）之外的变量**。简单来说，就是一个定义在函数内部的函数，它可以‘记住’并访问其外部函数的变量，即使外部函数已经执行完毕。

闭包有两个主要应用：

1. **创建私有变量**: 模拟面向对象编程中的私有成员。外部无法直接访问闭包内的变量，只能通过闭包暴露出来的接口访问。
    
2. **让变量持久化**: 外部函数的变量因为被内部函数引用，所以不会被垃圾回收机制回收，从而实现了变量生命周期的延长。”
    

---

#### **28. 内存泄露**

“内存泄露是指程序中不再需要使用的内存，由于某种原因没有被释放，导致它一直被占用。在 JavaScript 中，常见的内存泄露场景有：

1. **意外的全局变量**: 未经声明就赋值的变量会成为全局变量，难以被回收。
    
2. **遗忘的定时器**: `setInterval` 或 `setTimeout` 如果没有在组件销毁时（比如 Vue 的 `beforeUnmount`）通过 `clearInterval` 或 `clearTimeout` 清除，它们的回调函数和相关变量会一直存在于内存中。
    
3. **未移除的事件监听器**: 给 DOM 元素添加了事件监听，但在元素被移除时没有通过 `removeEventListener` 移除监听器。
    
4. **不当的闭包使用**: 闭包会使其外部函数的变量常驻内存，如果这些变量引用了大量数据，就可能导致泄露。”
    

---

#### **29. JS 的事件运行机制 (Event Loop)**

“JavaScript 是单线程的，但通过**事件循环 (Event Loop)** 机制实现了异步。

1. 所有同步任务都在**主线程**上执行，形成一个**执行栈 (Call Stack)**。
    
2. 当遇到异步任务（如 `setTimeout`、网络请求）时，会将其交给**宿主环境（浏览器或 Node.js）的 Web APIs**去处理，然后主线程继续执行后面的同步任务。
    
3. 当异步任务完成后（比如定时器到时、数据返回），其对应的**回调函数**会被放入一个**任务队列 (Task Queue)** 中等待。
    
4. **事件循环**会不断地轮询，检查执行栈是否为空。一旦执行栈为空，它就会从任务队列中取出一个任务，压入执行栈中执行。
    

这个过程不断重复，就是事件循环。”

---

#### **30. JS 的继承**

“JavaScript 的继承主要是基于**原型链**。

- **ES5 中的实现**: 主要通过**构造函数 + 原型对象**的方式。让子类的原型对象 (`Child.prototype`) 指向一个父类的实例 (`new Parent()`)，从而继承父类原型上的方法。同时，在子类构造函数中通过 `Parent.call(this)` 来继承父类的实例属性。
    
- **ES6 中的实现**: 引入了 `class` 语法糖，让继承的写法更清晰。通过 `class Child extends Parent` 和在 `constructor` 中调用 `super()` 来实现继承，但其底层原理仍然是原型链。”
    

---

#### **31. 原型链**

“每个 JavaScript 对象都有一个指向其**原型对象 (prototype)** 的内部链接。这个原型对象自己也有一个原型，如此层层向上，直到一个对象的原型为 `null`。由这些原型组成的链条就叫做**原型链**。

当我们试图访问一个对象的属性时，JavaScript 引擎会先在对象自身上查找。如果找不到，就会沿着原型链向上查找，直到找到该属性或到达链的末端。”

---

#### **32. 宏任务和微任务**

“宏任务和微任务都是异步任务，但它们的执行时机不同，这进一步细化了事件循环模型。

- **宏任务 (Macrotask)**: 包括 `script` (整体代码)、`setTimeout`, `setInterval`, `I/O` 操作、UI 渲染等。每次事件循环只执行**一个**宏任务。
    
- **微任务 (Microtask)**: 包括 `Promise.then/catch/finally`, `queueMicrotask`, `MutationObserver` 等。
    

执行顺序是：

1. 执行一个宏任务（比如 `script` 标签里的代码）。
    
2. 执行过程中如果遇到微任务，就将其添加到**微任务队列**。
    
3. 这个宏任务执行完毕后，立即检查微任务队列，并**清空整个微任务队列**（即执行所有微任务）。
    
4. 然后进行 UI 渲染（如果有必要）。
    
5. 最后开始下一轮事件循环，执行下一个宏任务。
    

**关键点：在一个宏任务之后，下个宏任务之前，会执行完所有已有的微任务。**”

---

### **其他综合问题**

#### **33. 怎么实现图片预加载和图片缓存机制**

- **图片预加载**: 是指在图片被实际需要之前就提前加载。
    
    - **CSS 方式**: 使用 `:hover` 伪类设置背景图，当用户悬停时图片已经加载。
        
    - **JavaScript 方式**: 创建一个 `new Image()` 对象，并设置其 `.src` 属性，当 `.onload` 事件触发时，表示图片已加载到浏览器缓存中。
        
    - **HTML 方式**: 使用 `<link rel="preload" as="image" href="path/to/image.jpg">`，告诉浏览器提前加载这个资源。
        
- **图片缓存机制**: 主要是利用**浏览器缓存**。
    
    - **HTTP 缓存**: 这是最主要的缓存方式。通过服务器设置响应头（如 `Cache-Control`, `Expires`, `ETag`, `Last-Modified`），浏览器会根据这些头信息决定是否从缓存中读取图片，还是重新向服务器请求。
        
    - **Service Worker**: 对于 PWA 应用，可以使用 Service Worker 拦截网络请求，实现更精细的离线缓存策略。
        

---

#### **34. CSS 怎么实现垂直居中**

1. **Flexbox (最常用)**:
    
    CSS
    
    ```
    .parent {
      display: flex;
      align-items: center; /* 垂直居中 */
      justify-content: center; /* 水平居中 */
    }
    ```
    
2. **Grid**:
    
    CSS
    
    ```
    .parent {
      display: grid;
      place-items: center; /* 水平垂直同时居中 */
    }
    ```
    
3. **绝对定位 + transform**:
    
    CSS
    
    ```
    .parent { position: relative; }
    .child {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    ```
    

---

#### **35. 说一下盒子模型**

“CSS 盒子模型描述了 HTML 元素在页面上渲染时所占空间的矩形盒子。这个盒子由四个部分组成，从内到外依次是：

- **Content (内容区)**: 元素的实际内容，如文本和图片。
    
- **Padding (内边距)**: 内容区与边框之间的空间。
    
- **Border (边框)**: 包围内边距和内容的边框。
    
- **Margin (外边距)**: 边框之外，用于将该元素与其他元素隔开的空间。”
    

---

#### **36. 盒子模型和正常模型有什么不一样**

“这个问题应该是指**标准盒子模型**和**IE盒子模型（怪异盒子模型）**的区别，这两种模型可以通过 CSS 的 `box-sizing` 属性来切换。

- **标准盒子模型 (`box-sizing: content-box;`)**: 这是默认的模型。你设置的 `width` 和 `height` 只作用于**内容区 (Content)**。盒子的实际总宽度 = `width` + `padding` + `border` + `margin`。
    
- **IE 盒子模型 (`box-sizing: border-box;`)**: 你设置的 `width` 和 `height` 包含了**内容区、内边距和边框**。盒子的实际总宽度 = `width` + `margin`。
    

在现代前端开发中，我们通常会全局设置 `* { box-sizing: border-box; }`，因为它让布局计算变得更直观和简单。”

---

#### **37. 怎么实现登陆流程**

1. **前端**: 用户在登录页面输入用户名和密码，点击登录。
    
2. **前端**: 将用户名和密码通过 HTTPS POST 请求发送到后端 API。
    
3. **后端**: 验证用户名和密码。验证通过后，生成一个有时效性的 **Token** (通常是 JWT)，并将其返回给前端。
    
4. **前端**: 收到 Token 后，将其存储起来。通常会存在 **Pinia/Vuex** 中用于组件间共享，并使用 `pinia-plugin-persistedstate` 等插件将其同步到 **localStorage** 或 **Cookies** 中，以实现持久化登录。
    
5. **前端**: 之后的所有需要认证的请求，都在请求头（`Authorization` Header）中带上这个 Token。
    
6. **后端**: 对每个需要认证的请求，都验证其请求头中的 Token 是否有效。
    

---

#### **38. 登陆后，下次再打开后，你还要重新登陆吗**

“不需要。通过上一步将 Token **持久化存储**（比如在 localStorage 中），当用户下次打开应用时，我们可以在应用初始化阶段（比如 Vue 的 `created` 或 `setup` 钩子中）检查 localStorage 中是否存在有效的 Token。如果存在，就将它恢复到 Pinia/Vuex 的 state 中，并设置到 axios 的请求头里，这样用户就保持了登录状态。”

---

#### **39. git 的常用操作**

- `git clone <url>`: 克隆远程仓库。
    
- `git status`: 查看工作区状态。
    
- `git add <file>`: 将文件添加到暂存区。
    
- `git commit -m "message"`: 将暂存区内容提交到本地仓库。
    
- `git push`: 将本地提交推送到远程仓库。
    
- `git pull`: 拉取远程仓库的最新内容并合并。
    
- `git branch`: 查看、创建、删除分支。
    
- `git checkout <branch>`: 切换分支。
    
- `git merge <branch>`: 合并指定分支到当前分支。
    

---

#### **40. 发生冲突怎么办**

“当 `git pull` 或 `git merge` 时，如果 Git 无法自动合并文件，就会产生冲突。

解决步骤如下：

1. Git 会在冲突文件中用 `<<<<<<<`, `=======`, `>>>>>>>` 标记出不同分支的内容。
    
2. 手动编辑这些文件，决定保留哪些代码，删除标记符号。
    
3. 解决完所有冲突后，使用 `git add <resolved-file>` 将修复后的文件标记为已解决。
    
4. 最后，执行 `git commit` 来完成这次合并。”
    

---

#### **41. 怎么实现合并代码**

“主要有两种方式：

1. **`git merge`**: 这是最直接的合并方式。它会将一个分支的更改历史完整地合并到另一个分支，并生成一个新的合并提交（Merge Commit）。这种方式会保留分支的完整历史，但可能会让提交历史线变得复杂。
    
2. **`git rebase`**: 变基。它会找到两个分支的共同祖先，然后将当前分支的提交“移动”到目标分支的最新提交之后，形成一条线性的提交历史。这会让历史记录更整洁，但会改写提交历史。”
    

---

#### **42. vite 和 webpack 优化，这两个有什么区别**

“Vite 和 Webpack 都是前端构建工具，但它们的核心工作模式和优化思路有很大不同。

- **Webpack**: 是一个**打包器 (Bundler)**。在开发环境下，它会从入口文件开始，分析整个项目的依赖关系，将所有模块打包成一个或多个 bundle 文件，然后启动开发服务器。对于大型项目，这个启动过程可能很慢。
    
- **Vite**: 利用了现代浏览器对**原生 ES 模块 (ESM)** 的支持。在开发环境下，它不需要打包，而是直接启动一个服务器。当浏览器请求一个模块时，Vite 会按需编译并返回该模块。这使得开发服务器的**启动速度几乎是瞬时**的。
    

**优化区别**:

- **Webpack 优化**: 重点在于如何**减少打包体积**和**提升打包速度**，比如通过代码分割 (`SplitChunks`)、Tree Shaking、压缩、配置 loader 缓存等。
    
- **Vite 优化**: 它的开发体验已经非常好了。生产环境打包它底层使用的是 **Rollup**，Rollup 本身在打包库和应用方面就非常高效。Vite 的优化更多是开箱即用的。
    

我在‘品优生活’项目中就使用了 Vite，它极大地提升了我的开发效率。”

---

#### **43. 如果一个界面请求很多个接口，这种要怎么处理**

“如果这些接口之间没有依赖关系，并且需要同时获取它们的数据，我会使用 `Promise.all()` 来进行**并行处理**。

`Promise.all()` 接收一个 Promise 数组，当数组中所有的 Promise 都成功时，它才会成功，并返回一个包含所有结果的数组。如果其中任何一个 Promise 失败，它就会立即失败。

这样做的好处是，所有请求会同时发出，总的等待时间取决于最慢的那个请求，而不是所有请求时间的总和，从而大大缩短了页面的总加载时间。”

---

#### **44. promise 有什么办法进行并行处理**

这个问题和上一个基本一样。

“Promise 提供了 `Promise.all()` 和 `Promise.allSettled()` 两种方法来进行并行处理。

- **`Promise.all()`**: 当你需要所有请求都成功时才进行下一步操作时使用。
    
- **`Promise.allSettled()`**: 当你关心所有请求的结果，无论成功或失败，都需要等待它们全部完成时使用。它返回的结果数组中会包含每个 Promise 的状态（`fulfilled` 或 `rejected`）和结果/原因。”
    

---

#### **45. vue3 的 teleprot**

“`Teleport` 是 Vue3 的一个内置组件，它的作用是**将一个组件的模板内容‘传送’到 DOM 树的另一个位置**。

最常见的应用场景就是**模态框 (Modal)**、**抽屉 (Drawer)** 或**通知 (Notification)**。这些组件在逻辑上属于某个组件，但在视觉上需要渲染在顶层（比如 `<body>` 标签下），以避免被父组件的 `overflow: hidden` 或 `z-index` 样式所影响。`Teleport` 完美地解决了这个问题。”

---

#### **46. ts 的 泛型**

“TypeScript 的泛型 (Generics) 是一种创建**可重用组件**的工具。一个组件，比如函数或类，可以支持多种类型的数据。泛型就像一个**类型的占位符**，在使用时再指定具体的类型。

例如，封装 `axios` 请求时，我们可以使用泛型来定义返回数据的类型：

TypeScript

```
function request<T>(url: string): Promise<T> {
  return axios.get(url).then(res => res.data as T);
}

// 使用时指定类型
interface User {
  id: number;
  name: string;
}
request<User>('/api/user/1').then(user => {
  // 这里的 user 就被推断为 User 类型
  console.log(user.name);
});
```

这样做的好处是代码更灵活，并且能在编译时就获得完整的类型安全检查。”

---

#### **47. 集成 echart 图表**

“在‘智慧餐饮管理系统’中，我负责了数据可视化模块的开发，深度集成了 ECharts。

集成步骤如下：

1. **安装和引入**: 通过 npm 安装 ECharts，然后在需要使用的 Vue 组件中按需引入。
    
2. **准备 DOM 容器**: 在模板中创建一个具有 `ref` 的 `<div>` 元素，作为 ECharts 的渲染容器。
    
3. **初始化实例**: 在 Vue 的 `onMounted` (或 `mounted`) 生命周期钩子中，通过 `echarts.init()` 方法，传入 DOM 容器来初始化一个 ECharts 实例。
    
4. **配置和渲染**: 编写 ECharts 的配置项 `option`，这是一个巨大的 JS 对象，定义了图表的类型、数据、坐标轴、图例、颜色等所有信息。然后调用 `myChart.setOption(option)` 来渲染图表。
    
5. **响应式和销毁**: 为了让图表能自适应容器大小变化，我会监听窗口的 `resize` 事件，并调用 `myChart.resize()` 方法。同时，在组件销毁前（`onBeforeUnmount` 钩子），调用 `myChart.dispose()` 来销毁实例，防止内存泄露。”